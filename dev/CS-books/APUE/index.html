<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>目录 · Liuxu&#39;s Wiki</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/documenter.css" rel="stylesheet" type="text/css"/><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link href="../../custom.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><h1>Liuxu&#39;s Wiki</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../../">Home</a></li><li><span class="toctext">Compute Science Book</span><ul><li><span class="toctext">Advanced Programming in the UNIX Environment</span><ul><li class="current"><a class="toctext" href>目录</a><ul class="internal"><li class="toplevel"><a class="toctext" href="#UNIX系统概括-1">UNIX系统概括</a></li><li><a class="toctext" href="#简介-1">简介</a></li><li><a class="toctext" href="#UNIX-架构-1">UNIX 架构</a></li><li><a class="toctext" href="#Logging-In-1">Logging In</a></li><li><a class="toctext" href="#文件和目录-1">文件和目录</a></li><li><a class="toctext" href="#输入和输出-1">输入和输出</a></li><li><a class="toctext" href="#进程-1">进程</a></li><li><a class="toctext" href="#错误处理-1">错误处理</a></li><li><a class="toctext" href="#用户识别-1">用户识别</a></li><li><a class="toctext" href="#信号-1">信号</a></li><li><a class="toctext" href="#时间-1">时间</a></li><li><a class="toctext" href="#系统调用和库函数-1">系统调用和库函数</a></li><li class="toplevel"><a class="toctext" href="#UNIX标准和实现-1">UNIX标准和实现</a></li><li><a class="toctext" href="#简介-2">简介</a></li><li><a class="toctext" href="#UNIX标准化-1">UNIX标准化</a></li><li><a class="toctext" href="#UNIX系统的各种实现-1">UNIX系统的各种实现</a></li><li><a class="toctext" href="#标准和实现的关系-1">标准和实现的关系</a></li><li><a class="toctext" href="#限制-1">限制</a></li><li><a class="toctext" href="#Options-1">Options</a></li><li><a class="toctext" href="#Primitive-System-Data-Types-1">Primitive System Data Types</a></li><li><a class="toctext" href="#标准间的不同-1">标准间的不同</a></li><li class="toplevel"><a class="toctext" href="#文件IO-1">文件IO</a></li><li><a class="toctext" href="#简介-3">简介</a></li><li><a class="toctext" href="#文件描述符-2">文件描述符</a></li><li><a class="toctext" href="#open-and-openat-函数-1"><code>open</code> and <code>openat</code> 函数</a></li><li><a class="toctext" href="#creat-函数-1"><code>creat</code> 函数</a></li><li><a class="toctext" href="#close-函数-1"><code>close</code> 函数</a></li><li><a class="toctext" href="#lseek-函数-1"><code>lseek</code> 函数</a></li><li><a class="toctext" href="#read-函数-1"><code>read</code> 函数</a></li><li><a class="toctext" href="#write-函数-1"><code>write</code> 函数</a></li><li><a class="toctext" href="#IO-效率-1">IO 效率</a></li><li><a class="toctext" href="#文件共享-1">文件共享</a></li><li><a class="toctext" href="#原子操作-1">原子操作</a></li><li><a class="toctext" href="#dup-dup2函数-1">dup dup2函数</a></li><li><a class="toctext" href="#sysnc，-fsync-和-fdatasync-函数-1"><code>sysnc</code>， <code>fsync</code> 和 <code>fdatasync</code> 函数</a></li><li><a class="toctext" href="#fcntl函数-1"><code>fcntl</code>函数</a></li><li><a class="toctext" href="#ioctl函数-1"><code>ioctl</code>函数</a></li><li><a class="toctext" href="#/dev/fd-1"><code>/dev/fd</code></a></li><li class="toplevel"><a class="toctext" href="#文件和目录-2">文件和目录</a></li><li><a class="toctext" href="#简介-4">简介</a></li><li><a class="toctext" href="#stat-函数等-1"><code>stat</code> 函数等</a></li><li><a class="toctext" href="#文件类型-1">文件类型</a></li><li><a class="toctext" href="#Set-User-ID-and-Set-Group-ID-1">Set-User-ID and Set-Group-ID</a></li><li><a class="toctext" href="#文件访问权限-1">文件访问权限</a></li><li><a class="toctext" href="#创建新文件时的所有权-1">创建新文件时的所有权</a></li></ul></li></ul></li></ul></li><li><span class="toctext">Algorithm</span><ul><li><a class="toctext" href="../../Algorithm/autodiff/">自动微分</a></li><li><span class="toctext">LeetCode</span><ul><li><a class="toctext" href="../../LeetCode/twostring/">String</a></li><li><a class="toctext" href="../../LeetCode/palindrome/">Palindrome</a></li><li><a class="toctext" href="../../LeetCode/array/">Array</a></li><li><a class="toctext" href="../../LeetCode/hash/">Hash</a></li><li><a class="toctext" href="../../LeetCode/heap/">Heap</a></li></ul></li></ul></li><li><span class="toctext">Languages</span><ul><li><span class="toctext">Python</span><ul><li><a class="toctext" href="../../Python/">Python 学习记录</a></li></ul></li><li><span class="toctext">Fortran</span><ul><li><a class="toctext" href="../../Fortran/Qsort/">Quick Sort</a></li></ul></li></ul></li><li><span class="toctext">系统运维</span><ul><li><a class="toctext" href="../../Ops/">系统运维</a></li><li><a class="toctext" href="../../Ops/git-summary/">Git</a></li></ul></li><li><span class="toctext">Digest</span><ul><li><a class="toctext" href="../../Digest/">鲁迅</a></li></ul></li><li><span class="toctext">年鉴</span><ul><li><a class="toctext" href="../../YearBook/">历史年鉴</a></li><li><a class="toctext" href="../../YearBook/peoples/">人物志</a></li></ul></li><li><span class="toctext">百科杂记</span><ul><li><a class="toctext" href="../../wiki/wiki/">组织</a></li></ul></li></ul></nav><article id="docs"><header><nav><ul><li>Compute Science Book</li><li>Advanced Programming in the UNIX Environment</li><li><a href>目录</a></li></ul><a class="edit-page" href="https://github.com/auxetic/wiki/blob/master/docs/src/CS-books/APUE/index.md#L"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>目录</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="目录-1" href="#目录-1">目录</a></h1><p>书籍内容</p><ol><li>UNIX系统概括</li><li>UNIX标准及其各种实现</li><li>文件I/O</li><li>文件和目录</li><li>标准I/O库</li><li>系统数据文件和信息</li><li>进程环境</li><li>进程控制</li><li>进程关系</li><li>信号</li><li>线程</li><li>线程控制</li><li>守护进程</li><li>高级I/O</li><li>进程间通信</li><li>网络IPC：套接字</li><li>高级IPC</li><li>终端I/O</li><li>伪终端</li><li>数据库</li><li>网络打印机</li></ol><h1><a class="nav-anchor" id="UNIX系统概括-1" href="#UNIX系统概括-1">UNIX系统概括</a></h1><h2><a class="nav-anchor" id="简介-1" href="#简介-1">简介</a></h2><p>所有的操作系统都要为程序运行提供服务，比如文件打开、读取，内存分配等等。 不适用前后引用，线性地描述UNIX系统基本是不可能的。 第一章这里对书中一些通用术语、概念和系统提供的各种服务给以简单的介绍。</p><h2><a class="nav-anchor" id="UNIX-架构-1" href="#UNIX-架构-1">UNIX 架构</a></h2><p>直接操作硬件的是内核（kernel）。 内核的接口是系统调用（system calls）。 系统调用之上有shell和库，应用程序可安需要使用系统调用、shell和库函数。</p><h2><a class="nav-anchor" id="Logging-In-1" href="#Logging-In-1">Logging In</a></h2><h3><a class="nav-anchor" id="登录名-1" href="#登录名-1">登录名</a></h3><p>通常/etc/passwd储存用户名信息，如 <code>liuxu:x:1000:1000:liuxu:/home/liuxu:/bin/bash</code></p><h3><a class="nav-anchor" id="shells-1" href="#shells-1">shells</a></h3><ol><li>sh = Bourne shell</li><li>bash = Bourne-again shell</li></ol><h2><a class="nav-anchor" id="文件和目录-1" href="#文件和目录-1">文件和目录</a></h2><h3><a class="nav-anchor" id="文件系统-1" href="#文件系统-1">文件系统</a></h3><p>目录十一个包含目录信息的文件</p><h3><a class="nav-anchor" id="文件名-1" href="#文件名-1">文件名</a></h3><p>文件名不能以/（slash）和null开头。当然POSIX有更严格的建议。</p><h3><a class="nav-anchor" id="路径-1" href="#路径-1">路径</a></h3><h3><a class="nav-anchor" id="例子-1" href="#例子-1">例子</a></h3><p>实现简单的<code>ls</code></p><pre><code class="language-c">#include &quot;apue.h&quot;
#include &lt;dirent.h&gt;

int main(int argc, char *argv[])
{
    DIR           *dp;
    struct dirent *dirp;

    if (argc != 2)
        err_quit(&quot;usage: ls directory_name&quot;);

    if ((dp = opendir(argv[1])) == NULL)
        err_sys(&quot;can&#39;t open %s&quot;, argv[1]);
	
    while ((dirp = readdir(dp)) != NULL)
        printf(&quot;%s\n&quot;, dirp-&gt;d_name);

    closedir(dp);
    exit(0);
}</code></pre><h3><a class="nav-anchor" id="工作目录-1" href="#工作目录-1">工作目录</a></h3><p>可以通过chdir函数切换</p><h3><a class="nav-anchor" id="Home目录-1" href="#Home目录-1">Home目录</a></h3><h2><a class="nav-anchor" id="输入和输出-1" href="#输入和输出-1">输入和输出</a></h2><h3><a class="nav-anchor" id="文件描述符-1" href="#文件描述符-1">文件描述符</a></h3><h3><a class="nav-anchor" id="标准输入、输出，标准错误输出-1" href="#标准输入、输出，标准错误输出-1">标准输入、输出，标准错误输出</a></h3><p>当shell执行一个新的程序时，总是会打开标题三个描述符</p><h3><a class="nav-anchor" id="无缓冲的I/O-1" href="#无缓冲的I/O-1">无缓冲的I/O</a></h3><h3><a class="nav-anchor" id="例子-2" href="#例子-2">例子</a></h3><p>从标准输入读取内容，输出至标准输出。STDIN_FILENO的定义等是POSIX标准的一部分，包含在&lt;unistd.h&gt;中。</p><pre><code class="language-c">#include &quot;apue.h&quot;
#define buffersize 4096

int main(int argc, char *argv[])
{
    int n;
    char buf[buffersize];

    while ((n=read(STDIN_FILENO, buf, buffersize)) &gt; 0)
        if (write(STDOUT_FILENO, buf, n) != n)
            err_sys(&quot;write error&quot;);

    if (n&lt;0)
        err_sys(&quot;read error&quot;);

    exit(0);
}</code></pre><h3><a class="nav-anchor" id="标准I/O-1" href="#标准I/O-1">标准I/O</a></h3><p>标准IO提供缓存</p><h3><a class="nav-anchor" id="例子-3" href="#例子-3">例子</a></h3><pre><code class="language-c">#include &quot;apue.h&quot;

int main(int argc, char *argv[])
{
    int c;
    while ((c = getc(stdin)) != EOF)
        if (putc(c, stdout) == EOF)
            err_sys(&quot;output error&quot;);

    if (ferror(stdin))
        err_sys(&quot;input error&quot;);

    exit(0);
}</code></pre><h2><a class="nav-anchor" id="进程-1" href="#进程-1">进程</a></h2><h3><a class="nav-anchor" id="（可执行）程序-1" href="#（可执行）程序-1">（可执行）程序</a></h3><h3><a class="nav-anchor" id="进程、进程ID-1" href="#进程、进程ID-1">进程、进程ID</a></h3><h3><a class="nav-anchor" id="例子-4" href="#例子-4">例子</a></h3><pre><code class="language-c">#include &quot;apue.h&quot;

int main(int argc, char *argv[])
{
    printf(&quot;hello world from process ID %ld\n&quot;, (long)getpid());
    exit(0);
}</code></pre><p>getpid()返回类型为pid_t，其实就是整型，但是我们不好知道具体长度，所以统一转换为长整型</p><h3><a class="nav-anchor" id="进程控制-1" href="#进程控制-1">进程控制</a></h3><p>主要有三种进程控制的函数：<code>fork</code>, <code>exec</code>, <code>waitpid</code>。 其中<code>exec</code>有七种变形。</p><h3><a class="nav-anchor" id="例子-5" href="#例子-5">例子</a></h3><pre><code class="language-c">#include &quot;apue.h&quot;
#include &lt;sys/wait.h&gt;

int main(int argc, char *argv[])
{
    char  buf[MAXLINE];
    pid_t pid;
    int   status;

    printf(&quot;%% &quot;);

    while (fgets(buf, MAXLINE, stdin) != NULL) {
        if ( buf[strlen(buf)-1] == &#39;\n&#39;)
            buf[strlen(buf)-1] = 0;

        if ((pid = fork()) &lt;0) {
            err_sys(&quot;fork error&quot;);
        } else if (pid == 0) {
            execlp(buf, buf, (char *)0);
            err_ret(&quot;couldn&#39;t execute: %s&quot;, buf);
            exit(127);
        }

        if ((pid=waitpid(pid, &amp;status, 0)) &lt; 0)
            err_sys(&quot;waitpid error&quot;);

        printf(&quot;%% &quot;);
    }

    exit(0);
}</code></pre><h3><a class="nav-anchor" id="线程、线程ID-1" href="#线程、线程ID-1">线程、线程ID</a></h3><p>多线程。一个进程内的多线程，共享相同的地址空间，文件描述符，栈，进程相关属性。 线程模型晚于UNIX诞生，进程与线程有着复杂的交互。</p><h2><a class="nav-anchor" id="错误处理-1" href="#错误处理-1">错误处理</a></h2><p>当程序运行出现错误，经常返回一个负值给系统，或者是一些用来表示错误的特定数值。 <code>&lt;errno.h&gt;</code>定义了一些常量，对应一些常见的错误。 <code>&lt;string.h&gt;</code>定义了<code>strerror</code>用来返回约定错误的信息。 <code>&lt;stdio.h&gt;</code>定义了<code>perror</code>函数根据当前errno想标准错误输出输出错误信息。</p><h3><a class="nav-anchor" id="例子-6" href="#例子-6">例子</a></h3><pre><code class="language-c">#include &quot;apue.h&quot;
#include &lt;errno.h&gt;

int main(int argc, char *argv[])
{
    fprintf(stderr, &quot;EACCES: %s\n&quot;, strerror(EACCES));
    errno = ENOENT;
    perror(argv[0]);
    exit(0);
}</code></pre><h3><a class="nav-anchor" id="错误恢复-1" href="#错误恢复-1">错误恢复</a></h3><p>错误分致命和非致命。致命错误没有恢复行为。当然是否致命取决于具体情形。</p><h2><a class="nav-anchor" id="用户识别-1" href="#用户识别-1">用户识别</a></h2><h3><a class="nav-anchor" id="用户ID-1" href="#用户ID-1">用户ID</a></h3><p>root账户uid为0</p><h3><a class="nav-anchor" id="组ID-1" href="#组ID-1">组ID</a></h3><p>POSIX标准规定，一个用户至少可以有8个组ID</p><h3><a class="nav-anchor" id="例子-7" href="#例子-7">例子</a></h3><pre><code class="language-c">#include &quot;apue.h&quot;

int main(int argc, char *argv[])
{
    printf(&quot;uid = %d, gid = %d\n&quot;, getuid(), getgid());
    exit(0);
}</code></pre><h2><a class="nav-anchor" id="信号-1" href="#信号-1">信号</a></h2><p>信号用来提醒进程有某些状况发生。进程可以选择忽略、默认处理、自行处理。</p><h2><a class="nav-anchor" id="时间-1" href="#时间-1">时间</a></h2><p>UNIX有两种时间值</p><ol><li>1970.2.1距当前是时间的秒数</li><li>进程时间，cpu时间安</li></ol><p>进程时间又有墙上时间，用户时间和系统时间的差别</p><h2><a class="nav-anchor" id="系统调用和库函数-1" href="#系统调用和库函数-1">系统调用和库函数</a></h2><p>从实现者的角度看，系统调用和库函数有着根本的不同；从用户的角度看，两者看起来都是标准的C函数形式。</p><h1><a class="nav-anchor" id="UNIX标准和实现-1" href="#UNIX标准和实现-1">UNIX标准和实现</a></h1><h2><a class="nav-anchor" id="简介-2" href="#简介-2">简介</a></h2><h2><a class="nav-anchor" id="UNIX标准化-1" href="#UNIX标准化-1">UNIX标准化</a></h2><h3><a class="nav-anchor" id="ISO-C-1" href="#ISO-C-1">ISO C</a></h3><p>ISO C不仅定义了语言的语法，还定义了标准库。C99没有影响本书涉及的POSIX接口。</p><h3><a class="nav-anchor" id="IEEE-POSIX-1" href="#IEEE-POSIX-1">IEEE POSIX</a></h3><p><code>POSIX</code> = Portable Operating System Interface。</p><h3><a class="nav-anchor" id="单一UNIX规范-1" href="#单一UNIX规范-1">单一UNIX规范</a></h3><p>The Single UNIX Specification 是POSIX.1的超集</p><h3><a class="nav-anchor" id="FIPS-1" href="#FIPS-1">FIPS</a></h3><p>Federal Information Processing Standard</p><h2><a class="nav-anchor" id="UNIX系统的各种实现-1" href="#UNIX系统的各种实现-1">UNIX系统的各种实现</a></h2><h3><a class="nav-anchor" id="System-V-Release-4-1" href="#System-V-Release-4-1">System V Release 4</a></h3><h3><a class="nav-anchor" id=".4-BSD-1" href="#.4-BSD-1">4.4 BSD</a></h3><p>Berkeley Software Distribution</p><h3><a class="nav-anchor" id="FreeBSD-1" href="#FreeBSD-1">FreeBSD</a></h3><p>基于4.4BSD-lite</p><h3><a class="nav-anchor" id="Linux-1" href="#Linux-1">Linux</a></h3><h3><a class="nav-anchor" id="Mac-OS-X-1" href="#Mac-OS-X-1">Mac OS X</a></h3><h3><a class="nav-anchor" id="Solaris-1" href="#Solaris-1">Solaris</a></h3><p>Sun Microsystems -&gt; Oracle</p><h3><a class="nav-anchor" id="others-1" href="#others-1">others</a></h3><h2><a class="nav-anchor" id="标准和实现的关系-1" href="#标准和实现的关系-1">标准和实现的关系</a></h2><h2><a class="nav-anchor" id="限制-1" href="#限制-1">限制</a></h2><p>各种UNIX实现都定义了各自的一些常量。一些是编译期的限定，一些是运行时的。</p><h3><a class="nav-anchor" id="ISO-C-Limits-1" href="#ISO-C-Limits-1">ISO C Limits</a></h3><p>int的上下限等等</p><h3><a class="nav-anchor" id="POSIX-Limits-1" href="#POSIX-Limits-1">POSIX Limits</a></h3><p>文件名长度限制等等</p><h3><a class="nav-anchor" id="XSI-Limits-1" href="#XSI-Limits-1">XSI Limits</a></h3><h3><a class="nav-anchor" id="sysconf，-pathconf，-fpathconf-1" href="#sysconf，-pathconf，-fpathconf-1"><code>sysconf</code>， <code>pathconf</code>， <code>fpathconf</code></a></h3><h3><a class="nav-anchor" id="Indeterminate-Runtime-Limits-1" href="#Indeterminate-Runtime-Limits-1">Indeterminate Runtime Limits</a></h3><h2><a class="nav-anchor" id="Options-1" href="#Options-1">Options</a></h2><h2><a class="nav-anchor" id="Primitive-System-Data-Types-1" href="#Primitive-System-Data-Types-1">Primitive System Data Types</a></h2><h2><a class="nav-anchor" id="标准间的不同-1" href="#标准间的不同-1">标准间的不同</a></h2><h1><a class="nav-anchor" id="文件IO-1" href="#文件IO-1">文件IO</a></h1><h2><a class="nav-anchor" id="简介-3" href="#简介-3">简介</a></h2><p>这一章描述的都是非缓冲IO</p><h2><a class="nav-anchor" id="文件描述符-2" href="#文件描述符-2">文件描述符</a></h2><p>一般情况下，0代表标准输入，1代表标准输出，2代表标准错误输出， 但是为了可移植性，推荐用<code>STDIN_FILENO</code>等替代。</p><h2><a class="nav-anchor" id="open-and-openat-函数-1" href="#open-and-openat-函数-1"><code>open</code> and <code>openat</code> 函数</a></h2><pre><code class="language-c">#include &lt;fcntl.h&gt;
int open(const char *path, int oflag, ...);
int openat(int fd, const char *path, int oflag, ...);</code></pre><p><code>oflag</code>可以为<code>O_RONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code>, <code>O_EXEC</code>, <code>O_SEARCH</code>。</p><h3><a class="nav-anchor" id="文件名、路径名截断-1" href="#文件名、路径名截断-1">文件名、路径名截断</a></h3><h2><a class="nav-anchor" id="creat-函数-1" href="#creat-函数-1"><code>creat</code> 函数</a></h2><pre><code class="language-c">#include &lt;fcntl.h&gt;
int creat(const char *path, mode_t mode);</code></pre><p>返回结果是一个可写的文件描述符。</p><h2><a class="nav-anchor" id="close-函数-1" href="#close-函数-1"><code>close</code> 函数</a></h2><pre><code class="language-c">#include &lt;unistd.h&gt;
int close(int fd);</code></pre><p>当一个进程结束时，kernel会自动关闭进程相关的所有文件。</p><h2><a class="nav-anchor" id="lseek-函数-1" href="#lseek-函数-1"><code>lseek</code> 函数</a></h2><pre><code class="language-c">#include &lt;unistd.h&gt;
off_t lseek(int fd, off_t offset, int whence);</code></pre><p>打开文件时，默认指向文件的开头，除非设置了<code>O_APPEND</code>。 whence可以设置为</p><ol><li>SEEK_SET</li><li>SEEK_CUR</li><li>SEEK_END</li></ol><p>某些文件描述符无法seek，如<code>FIFO</code>，socket等。 lseek只在内核中记录文件的offset</p><h2><a class="nav-anchor" id="read-函数-1" href="#read-函数-1"><code>read</code> 函数</a></h2><pre><code class="language-c">#include &lt;unistd.h&gt;
ssize_t read(int fd, void *buf, size_t nbytes);</code></pre><p>从文件描述符读取指定长短的内容，返回读到的长度。</p><h2><a class="nav-anchor" id="write-函数-1" href="#write-函数-1"><code>write</code> 函数</a></h2><pre><code class="language-c">#include &lt;unistd.h&gt;
ssize_t write(int fd, const void *buf, size_t nbytes);</code></pre><p>返回写入的长度，若发生错误，返回<code>-1</code></p><h2><a class="nav-anchor" id="IO-效率-1" href="#IO-效率-1">IO 效率</a></h2><p><code>read</code>和<code>write</code>函数均要指定缓存区大小。 过小的缓存会增加系统调用的次数，过大的缓存会造成内存浪费，所以这里存在一个调优的问题。 但实际的现代系统内核，往往有读写预缓存的优化。</p><h2><a class="nav-anchor" id="文件共享-1" href="#文件共享-1">文件共享</a></h2><h2><a class="nav-anchor" id="原子操作-1" href="#原子操作-1">原子操作</a></h2><p>文件共享时，有数据竟写的可能，所以需要原子操作。</p><h3><a class="nav-anchor" id="pread和pwrite函数-1" href="#pread和pwrite函数-1"><code>pread</code>和<code>pwrite</code>函数</a></h3><p>pread函数相当于lseek和write无间断连续运行。</p><h2><a class="nav-anchor" id="dup-dup2函数-1" href="#dup-dup2函数-1">dup dup2函数</a></h2><p>没看</p><h2><a class="nav-anchor" id="sysnc，-fsync-和-fdatasync-函数-1" href="#sysnc，-fsync-和-fdatasync-函数-1"><code>sysnc</code>， <code>fsync</code> 和 <code>fdatasync</code> 函数</a></h2><p>UNIX类系统为了读写优化，一般都启用了延迟写入特性。 如果我们需要同步磁盘与内存缓存，会用到以下几个函数。</p><pre><code class="language-c">#include &lt;unistd.h&gt;
int fsync(int fd);
int fdatasync(int fd);
void sync(void);</code></pre><p><code>fdatasync</code>和<code>fsync</code>类似，差别在于是否同步文件属性。</p><h2><a class="nav-anchor" id="fcntl函数-1" href="#fcntl函数-1"><code>fcntl</code>函数</a></h2><h2><a class="nav-anchor" id="ioctl函数-1" href="#ioctl函数-1"><code>ioctl</code>函数</a></h2><h2><a class="nav-anchor" id="/dev/fd-1" href="#/dev/fd-1"><code>/dev/fd</code></a></h2><h1><a class="nav-anchor" id="文件和目录-2" href="#文件和目录-2">文件和目录</a></h1><h2><a class="nav-anchor" id="简介-4" href="#简介-4">简介</a></h2><p>这一章介绍一些文件系统的特性和文件属性。这一章从介绍<code>stat</code>函数开始。</p><h2><a class="nav-anchor" id="stat-函数等-1" href="#stat-函数等-1"><code>stat</code> 函数等</a></h2><pre><code class="language-c">#include &lt;sys/stat.h&gt;
int stat(const char *restrict pathname, struct stat *restrict buf);
int fstat
int lstat
int fstatat</code></pre><pre><code class="language-c">struct stat {
    mode_t          st_mode;    /* file type &amp; mode (permissions) */
    ino_t           st_ino;     /* i-node number (serial number) */
    dev_t           st_dev;     /* device number (file system) */
    dev_t           st_rdev;    /* device number for special files */
    nlink_t         st_nlink;   /* number of links */
    uid_t           st_uid;     /* user ID of owner */
    gid_t           st_gid;     /* group ID of owner */
    off_t           st_size;    /* size in bytes, for regular files */
    struct timespec st_atim;    /* time of last access */
    struct timespec st_mtim;    /* time of last modification */
    struct timespec st_ctim;    /* time of last file status change */
    blksize_t       st_blksize; /* best I/O block size */
    blkcnt_t        st_blocks;  /* number of disk blocks allocated */
};</code></pre><h2><a class="nav-anchor" id="文件类型-1" href="#文件类型-1">文件类型</a></h2><ol><li>普通文件</li><li>目录</li><li>块设备文件</li><li>字符设备文件</li><li>管道FIFO</li><li>套接字Socket</li><li>符号链接</li></ol><h2><a class="nav-anchor" id="Set-User-ID-and-Set-Group-ID-1" href="#Set-User-ID-and-Set-Group-ID-1">Set-User-ID and Set-Group-ID</a></h2><p>每一个进程都至少关联有六个ID。每一个文件都从属于某各人和组。 UNIX系统允许每个用户修改自己的密码。当普通用户执行passwd，程序可以获得/etc/passwd文件的读写权限，而这个文件的主人，显然是root。</p><h2><a class="nav-anchor" id="文件访问权限-1" href="#文件访问权限-1">文件访问权限</a></h2><h2><a class="nav-anchor" id="创建新文件时的所有权-1" href="#创建新文件时的所有权-1">创建新文件时的所有权</a></h2><footer><hr/><a class="previous" href="../../"><span class="direction">Previous</span><span class="title">Home</span></a><a class="next" href="../../Algorithm/autodiff/"><span class="direction">Next</span><span class="title">自动微分</span></a></footer></article></body></html>
