<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>目录 · Liuxu&#39;s Wiki</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link href="../../assets/favicon.ico" rel="icon" type="image/x-icon"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit">Liuxu&#39;s Wiki</span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>目录</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>目录</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/auxetic/wiki/blob/master/docs/src/CS-books/APUE/index.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="目录-1"><a class="docs-heading-anchor" href="#目录-1">目录</a><a class="docs-heading-anchor-permalink" href="#目录-1" title="Permalink"></a></h1><p>书籍内容</p><ol><li>UNIX系统概括</li><li>UNIX标准及其各种实现</li><li>文件I/O</li><li>文件和目录</li><li>标准I/O库</li><li>系统数据文件和信息</li><li>进程环境</li><li>进程控制</li><li>进程关系</li><li>信号</li><li>线程</li><li>线程控制</li><li>守护进程</li><li>高级I/O</li><li>进程间通信</li><li>网络IPC：套接字</li><li>高级IPC</li><li>终端I/O</li><li>伪终端</li><li>数据库</li><li>网络打印机</li></ol><h1 id="UNIX系统概括-1"><a class="docs-heading-anchor" href="#UNIX系统概括-1">UNIX系统概括</a><a class="docs-heading-anchor-permalink" href="#UNIX系统概括-1" title="Permalink"></a></h1><h2 id="简介-1"><a class="docs-heading-anchor" href="#简介-1">简介</a><a class="docs-heading-anchor-permalink" href="#简介-1" title="Permalink"></a></h2><p>所有的操作系统都要为程序运行提供服务，比如文件打开、读取，内存分配等等。 不适用前后引用，线性地描述UNIX系统基本是不可能的。 第一章这里对书中一些通用术语、概念和系统提供的各种服务给以简单的介绍。</p><h2 id="UNIX-架构-1"><a class="docs-heading-anchor" href="#UNIX-架构-1">UNIX 架构</a><a class="docs-heading-anchor-permalink" href="#UNIX-架构-1" title="Permalink"></a></h2><p>直接操作硬件的是内核（kernel）。 内核的接口是系统调用（system calls）。 系统调用之上有shell和库，应用程序可安需要使用系统调用、shell和库函数。</p><h2 id="Logging-In-1"><a class="docs-heading-anchor" href="#Logging-In-1">Logging In</a><a class="docs-heading-anchor-permalink" href="#Logging-In-1" title="Permalink"></a></h2><h3 id="登录名-1"><a class="docs-heading-anchor" href="#登录名-1">登录名</a><a class="docs-heading-anchor-permalink" href="#登录名-1" title="Permalink"></a></h3><p>通常/etc/passwd储存用户名信息，如 <code>liuxu:x:1000:1000:liuxu:/home/liuxu:/bin/bash</code></p><h3 id="shells-1"><a class="docs-heading-anchor" href="#shells-1">shells</a><a class="docs-heading-anchor-permalink" href="#shells-1" title="Permalink"></a></h3><ol><li>sh = Bourne shell</li><li>bash = Bourne-again shell</li></ol><h2 id="文件和目录-1"><a class="docs-heading-anchor" href="#文件和目录-1">文件和目录</a><a class="docs-heading-anchor-permalink" href="#文件和目录-1" title="Permalink"></a></h2><h3 id="文件系统-1"><a class="docs-heading-anchor" href="#文件系统-1">文件系统</a><a class="docs-heading-anchor-permalink" href="#文件系统-1" title="Permalink"></a></h3><p>目录十一个包含目录信息的文件</p><h3 id="文件名-1"><a class="docs-heading-anchor" href="#文件名-1">文件名</a><a class="docs-heading-anchor-permalink" href="#文件名-1" title="Permalink"></a></h3><p>文件名不能以/（slash）和null开头。当然POSIX有更严格的建议。</p><h3 id="路径-1"><a class="docs-heading-anchor" href="#路径-1">路径</a><a class="docs-heading-anchor-permalink" href="#路径-1" title="Permalink"></a></h3><h3 id="例子-1"><a class="docs-heading-anchor" href="#例子-1">例子</a><a class="docs-heading-anchor-permalink" href="#例子-1" title="Permalink"></a></h3><p>实现简单的<code>ls</code></p><pre><code class="language-c">#include &quot;apue.h&quot;
#include &lt;dirent.h&gt;

int main(int argc, char *argv[])
{
    DIR           *dp;
    struct dirent *dirp;

    if (argc != 2)
        err_quit(&quot;usage: ls directory_name&quot;);

    if ((dp = opendir(argv[1])) == NULL)
        err_sys(&quot;can&#39;t open %s&quot;, argv[1]);
	
    while ((dirp = readdir(dp)) != NULL)
        printf(&quot;%s\n&quot;, dirp-&gt;d_name);

    closedir(dp);
    exit(0);
}</code></pre><h3 id="工作目录-1"><a class="docs-heading-anchor" href="#工作目录-1">工作目录</a><a class="docs-heading-anchor-permalink" href="#工作目录-1" title="Permalink"></a></h3><p>可以通过chdir函数切换</p><h3 id="Home目录-1"><a class="docs-heading-anchor" href="#Home目录-1">Home目录</a><a class="docs-heading-anchor-permalink" href="#Home目录-1" title="Permalink"></a></h3><h2 id="输入和输出-1"><a class="docs-heading-anchor" href="#输入和输出-1">输入和输出</a><a class="docs-heading-anchor-permalink" href="#输入和输出-1" title="Permalink"></a></h2><h3 id="文件描述符-1"><a class="docs-heading-anchor" href="#文件描述符-1">文件描述符</a><a class="docs-heading-anchor-permalink" href="#文件描述符-1" title="Permalink"></a></h3><h3 id="标准输入、输出，标准错误输出-1"><a class="docs-heading-anchor" href="#标准输入、输出，标准错误输出-1">标准输入、输出，标准错误输出</a><a class="docs-heading-anchor-permalink" href="#标准输入、输出，标准错误输出-1" title="Permalink"></a></h3><p>当shell执行一个新的程序时，总是会打开标题三个描述符</p><h3 id="无缓冲的I/O-1"><a class="docs-heading-anchor" href="#无缓冲的I/O-1">无缓冲的I/O</a><a class="docs-heading-anchor-permalink" href="#无缓冲的I/O-1" title="Permalink"></a></h3><h3 id="例子-2"><a class="docs-heading-anchor" href="#例子-2">例子</a><a class="docs-heading-anchor-permalink" href="#例子-2" title="Permalink"></a></h3><p>从标准输入读取内容，输出至标准输出。STDIN_FILENO的定义等是POSIX标准的一部分，包含在&lt;unistd.h&gt;中。</p><pre><code class="language-c">#include &quot;apue.h&quot;
#define buffersize 4096

int main(int argc, char *argv[])
{
    int n;
    char buf[buffersize];

    while ((n=read(STDIN_FILENO, buf, buffersize)) &gt; 0)
        if (write(STDOUT_FILENO, buf, n) != n)
            err_sys(&quot;write error&quot;);

    if (n&lt;0)
        err_sys(&quot;read error&quot;);

    exit(0);
}</code></pre><h3 id="标准I/O-1"><a class="docs-heading-anchor" href="#标准I/O-1">标准I/O</a><a class="docs-heading-anchor-permalink" href="#标准I/O-1" title="Permalink"></a></h3><p>标准IO提供缓存</p><h3 id="例子-3"><a class="docs-heading-anchor" href="#例子-3">例子</a><a class="docs-heading-anchor-permalink" href="#例子-3" title="Permalink"></a></h3><pre><code class="language-c">#include &quot;apue.h&quot;

int main(int argc, char *argv[])
{
    int c;
    while ((c = getc(stdin)) != EOF)
        if (putc(c, stdout) == EOF)
            err_sys(&quot;output error&quot;);

    if (ferror(stdin))
        err_sys(&quot;input error&quot;);

    exit(0);
}</code></pre><h2 id="进程-1"><a class="docs-heading-anchor" href="#进程-1">进程</a><a class="docs-heading-anchor-permalink" href="#进程-1" title="Permalink"></a></h2><h3 id="（可执行）程序-1"><a class="docs-heading-anchor" href="#（可执行）程序-1">（可执行）程序</a><a class="docs-heading-anchor-permalink" href="#（可执行）程序-1" title="Permalink"></a></h3><h3 id="进程、进程ID-1"><a class="docs-heading-anchor" href="#进程、进程ID-1">进程、进程ID</a><a class="docs-heading-anchor-permalink" href="#进程、进程ID-1" title="Permalink"></a></h3><h3 id="例子-4"><a class="docs-heading-anchor" href="#例子-4">例子</a><a class="docs-heading-anchor-permalink" href="#例子-4" title="Permalink"></a></h3><pre><code class="language-c">#include &quot;apue.h&quot;

int main(int argc, char *argv[])
{
    printf(&quot;hello world from process ID %ld\n&quot;, (long)getpid());
    exit(0);
}</code></pre><p>getpid()返回类型为pid_t，其实就是整型，但是我们不好知道具体长度，所以统一转换为长整型</p><h3 id="进程控制-1"><a class="docs-heading-anchor" href="#进程控制-1">进程控制</a><a class="docs-heading-anchor-permalink" href="#进程控制-1" title="Permalink"></a></h3><p>主要有三种进程控制的函数：<code>fork</code>, <code>exec</code>, <code>waitpid</code>。 其中<code>exec</code>有七种变形。</p><h3 id="例子-5"><a class="docs-heading-anchor" href="#例子-5">例子</a><a class="docs-heading-anchor-permalink" href="#例子-5" title="Permalink"></a></h3><pre><code class="language-c">#include &quot;apue.h&quot;
#include &lt;sys/wait.h&gt;

int main(int argc, char *argv[])
{
    char  buf[MAXLINE];
    pid_t pid;
    int   status;

    printf(&quot;%% &quot;);

    while (fgets(buf, MAXLINE, stdin) != NULL) {
        if ( buf[strlen(buf)-1] == &#39;\n&#39;)
            buf[strlen(buf)-1] = 0;

        if ((pid = fork()) &lt;0) {
            err_sys(&quot;fork error&quot;);
        } else if (pid == 0) {
            execlp(buf, buf, (char *)0);
            err_ret(&quot;couldn&#39;t execute: %s&quot;, buf);
            exit(127);
        }

        if ((pid=waitpid(pid, &amp;status, 0)) &lt; 0)
            err_sys(&quot;waitpid error&quot;);

        printf(&quot;%% &quot;);
    }

    exit(0);
}</code></pre><h3 id="线程、线程ID-1"><a class="docs-heading-anchor" href="#线程、线程ID-1">线程、线程ID</a><a class="docs-heading-anchor-permalink" href="#线程、线程ID-1" title="Permalink"></a></h3><p>多线程。一个进程内的多线程，共享相同的地址空间，文件描述符，栈，进程相关属性。 线程模型晚于UNIX诞生，进程与线程有着复杂的交互。</p><h2 id="错误处理-1"><a class="docs-heading-anchor" href="#错误处理-1">错误处理</a><a class="docs-heading-anchor-permalink" href="#错误处理-1" title="Permalink"></a></h2><p>当程序运行出现错误，经常返回一个负值给系统，或者是一些用来表示错误的特定数值。 <code>&lt;errno.h&gt;</code>定义了一些常量，对应一些常见的错误。 <code>&lt;string.h&gt;</code>定义了<code>strerror</code>用来返回约定错误的信息。 <code>&lt;stdio.h&gt;</code>定义了<code>perror</code>函数根据当前errno想标准错误输出输出错误信息。</p><h3 id="例子-6"><a class="docs-heading-anchor" href="#例子-6">例子</a><a class="docs-heading-anchor-permalink" href="#例子-6" title="Permalink"></a></h3><pre><code class="language-c">#include &quot;apue.h&quot;
#include &lt;errno.h&gt;

int main(int argc, char *argv[])
{
    fprintf(stderr, &quot;EACCES: %s\n&quot;, strerror(EACCES));
    errno = ENOENT;
    perror(argv[0]);
    exit(0);
}</code></pre><h3 id="错误恢复-1"><a class="docs-heading-anchor" href="#错误恢复-1">错误恢复</a><a class="docs-heading-anchor-permalink" href="#错误恢复-1" title="Permalink"></a></h3><p>错误分致命和非致命。致命错误没有恢复行为。当然是否致命取决于具体情形。</p><h2 id="用户识别-1"><a class="docs-heading-anchor" href="#用户识别-1">用户识别</a><a class="docs-heading-anchor-permalink" href="#用户识别-1" title="Permalink"></a></h2><h3 id="用户ID-1"><a class="docs-heading-anchor" href="#用户ID-1">用户ID</a><a class="docs-heading-anchor-permalink" href="#用户ID-1" title="Permalink"></a></h3><p>root账户uid为0</p><h3 id="组ID-1"><a class="docs-heading-anchor" href="#组ID-1">组ID</a><a class="docs-heading-anchor-permalink" href="#组ID-1" title="Permalink"></a></h3><p>POSIX标准规定，一个用户至少可以有8个组ID</p><h3 id="例子-7"><a class="docs-heading-anchor" href="#例子-7">例子</a><a class="docs-heading-anchor-permalink" href="#例子-7" title="Permalink"></a></h3><pre><code class="language-c">#include &quot;apue.h&quot;

int main(int argc, char *argv[])
{
    printf(&quot;uid = %d, gid = %d\n&quot;, getuid(), getgid());
    exit(0);
}</code></pre><h2 id="信号-1"><a class="docs-heading-anchor" href="#信号-1">信号</a><a class="docs-heading-anchor-permalink" href="#信号-1" title="Permalink"></a></h2><p>信号用来提醒进程有某些状况发生。进程可以选择忽略、默认处理、自行处理。</p><h2 id="时间-1"><a class="docs-heading-anchor" href="#时间-1">时间</a><a class="docs-heading-anchor-permalink" href="#时间-1" title="Permalink"></a></h2><p>UNIX有两种时间值</p><ol><li>1970.2.1距当前是时间的秒数</li><li>进程时间，cpu时间安</li></ol><p>进程时间又有墙上时间，用户时间和系统时间的差别</p><h2 id="系统调用和库函数-1"><a class="docs-heading-anchor" href="#系统调用和库函数-1">系统调用和库函数</a><a class="docs-heading-anchor-permalink" href="#系统调用和库函数-1" title="Permalink"></a></h2><p>从实现者的角度看，系统调用和库函数有着根本的不同；从用户的角度看，两者看起来都是标准的C函数形式。</p><h1 id="UNIX标准和实现-1"><a class="docs-heading-anchor" href="#UNIX标准和实现-1">UNIX标准和实现</a><a class="docs-heading-anchor-permalink" href="#UNIX标准和实现-1" title="Permalink"></a></h1><h2 id="简介-2"><a class="docs-heading-anchor" href="#简介-2">简介</a><a class="docs-heading-anchor-permalink" href="#简介-2" title="Permalink"></a></h2><h2 id="UNIX标准化-1"><a class="docs-heading-anchor" href="#UNIX标准化-1">UNIX标准化</a><a class="docs-heading-anchor-permalink" href="#UNIX标准化-1" title="Permalink"></a></h2><h3 id="ISO-C-1"><a class="docs-heading-anchor" href="#ISO-C-1">ISO C</a><a class="docs-heading-anchor-permalink" href="#ISO-C-1" title="Permalink"></a></h3><p>ISO C不仅定义了语言的语法，还定义了标准库。C99没有影响本书涉及的POSIX接口。</p><h3 id="IEEE-POSIX-1"><a class="docs-heading-anchor" href="#IEEE-POSIX-1">IEEE POSIX</a><a class="docs-heading-anchor-permalink" href="#IEEE-POSIX-1" title="Permalink"></a></h3><p><code>POSIX</code> = Portable Operating System Interface。</p><h3 id="单一UNIX规范-1"><a class="docs-heading-anchor" href="#单一UNIX规范-1">单一UNIX规范</a><a class="docs-heading-anchor-permalink" href="#单一UNIX规范-1" title="Permalink"></a></h3><p>The Single UNIX Specification 是POSIX.1的超集</p><h3 id="FIPS-1"><a class="docs-heading-anchor" href="#FIPS-1">FIPS</a><a class="docs-heading-anchor-permalink" href="#FIPS-1" title="Permalink"></a></h3><p>Federal Information Processing Standard</p><h2 id="UNIX系统的各种实现-1"><a class="docs-heading-anchor" href="#UNIX系统的各种实现-1">UNIX系统的各种实现</a><a class="docs-heading-anchor-permalink" href="#UNIX系统的各种实现-1" title="Permalink"></a></h2><h3 id="System-V-Release-4-1"><a class="docs-heading-anchor" href="#System-V-Release-4-1">System V Release 4</a><a class="docs-heading-anchor-permalink" href="#System-V-Release-4-1" title="Permalink"></a></h3><h3 id=".4-BSD-1"><a class="docs-heading-anchor" href="#.4-BSD-1">4.4 BSD</a><a class="docs-heading-anchor-permalink" href="#.4-BSD-1" title="Permalink"></a></h3><p>Berkeley Software Distribution</p><h3 id="FreeBSD-1"><a class="docs-heading-anchor" href="#FreeBSD-1">FreeBSD</a><a class="docs-heading-anchor-permalink" href="#FreeBSD-1" title="Permalink"></a></h3><p>基于4.4BSD-lite</p><h3 id="Linux-1"><a class="docs-heading-anchor" href="#Linux-1">Linux</a><a class="docs-heading-anchor-permalink" href="#Linux-1" title="Permalink"></a></h3><h3 id="Mac-OS-X-1"><a class="docs-heading-anchor" href="#Mac-OS-X-1">Mac OS X</a><a class="docs-heading-anchor-permalink" href="#Mac-OS-X-1" title="Permalink"></a></h3><h3 id="Solaris-1"><a class="docs-heading-anchor" href="#Solaris-1">Solaris</a><a class="docs-heading-anchor-permalink" href="#Solaris-1" title="Permalink"></a></h3><p>Sun Microsystems -&gt; Oracle</p><h3 id="others-1"><a class="docs-heading-anchor" href="#others-1">others</a><a class="docs-heading-anchor-permalink" href="#others-1" title="Permalink"></a></h3><h2 id="标准和实现的关系-1"><a class="docs-heading-anchor" href="#标准和实现的关系-1">标准和实现的关系</a><a class="docs-heading-anchor-permalink" href="#标准和实现的关系-1" title="Permalink"></a></h2><h2 id="限制-1"><a class="docs-heading-anchor" href="#限制-1">限制</a><a class="docs-heading-anchor-permalink" href="#限制-1" title="Permalink"></a></h2><p>各种UNIX实现都定义了各自的一些常量。一些是编译期的限定，一些是运行时的。</p><h3 id="ISO-C-Limits-1"><a class="docs-heading-anchor" href="#ISO-C-Limits-1">ISO C Limits</a><a class="docs-heading-anchor-permalink" href="#ISO-C-Limits-1" title="Permalink"></a></h3><p>int的上下限等等</p><h3 id="POSIX-Limits-1"><a class="docs-heading-anchor" href="#POSIX-Limits-1">POSIX Limits</a><a class="docs-heading-anchor-permalink" href="#POSIX-Limits-1" title="Permalink"></a></h3><p>文件名长度限制等等</p><h3 id="XSI-Limits-1"><a class="docs-heading-anchor" href="#XSI-Limits-1">XSI Limits</a><a class="docs-heading-anchor-permalink" href="#XSI-Limits-1" title="Permalink"></a></h3><h3 id="sysconf，-pathconf，-fpathconf-1"><a class="docs-heading-anchor" href="#sysconf，-pathconf，-fpathconf-1"><code>sysconf</code>， <code>pathconf</code>， <code>fpathconf</code></a><a class="docs-heading-anchor-permalink" href="#sysconf，-pathconf，-fpathconf-1" title="Permalink"></a></h3><h3 id="Indeterminate-Runtime-Limits-1"><a class="docs-heading-anchor" href="#Indeterminate-Runtime-Limits-1">Indeterminate Runtime Limits</a><a class="docs-heading-anchor-permalink" href="#Indeterminate-Runtime-Limits-1" title="Permalink"></a></h3><h2 id="Options-1"><a class="docs-heading-anchor" href="#Options-1">Options</a><a class="docs-heading-anchor-permalink" href="#Options-1" title="Permalink"></a></h2><h2 id="Primitive-System-Data-Types-1"><a class="docs-heading-anchor" href="#Primitive-System-Data-Types-1">Primitive System Data Types</a><a class="docs-heading-anchor-permalink" href="#Primitive-System-Data-Types-1" title="Permalink"></a></h2><h2 id="标准间的不同-1"><a class="docs-heading-anchor" href="#标准间的不同-1">标准间的不同</a><a class="docs-heading-anchor-permalink" href="#标准间的不同-1" title="Permalink"></a></h2><h1 id="文件IO-1"><a class="docs-heading-anchor" href="#文件IO-1">文件IO</a><a class="docs-heading-anchor-permalink" href="#文件IO-1" title="Permalink"></a></h1><h2 id="简介-3"><a class="docs-heading-anchor" href="#简介-3">简介</a><a class="docs-heading-anchor-permalink" href="#简介-3" title="Permalink"></a></h2><p>这一章描述的都是非缓冲IO</p><h2 id="文件描述符-2"><a class="docs-heading-anchor" href="#文件描述符-2">文件描述符</a><a class="docs-heading-anchor-permalink" href="#文件描述符-2" title="Permalink"></a></h2><p>一般情况下，0代表标准输入，1代表标准输出，2代表标准错误输出， 但是为了可移植性，推荐用<code>STDIN_FILENO</code>等替代。</p><h2 id="open-and-openat-函数-1"><a class="docs-heading-anchor" href="#open-and-openat-函数-1"><code>open</code> and <code>openat</code> 函数</a><a class="docs-heading-anchor-permalink" href="#open-and-openat-函数-1" title="Permalink"></a></h2><pre><code class="language-c">#include &lt;fcntl.h&gt;
int open(const char *path, int oflag, ...);
int openat(int fd, const char *path, int oflag, ...);</code></pre><p><code>oflag</code>可以为<code>O_RONLY</code>, <code>O_WRONLY</code>, <code>O_RDWR</code>, <code>O_EXEC</code>, <code>O_SEARCH</code>。</p><h3 id="文件名、路径名截断-1"><a class="docs-heading-anchor" href="#文件名、路径名截断-1">文件名、路径名截断</a><a class="docs-heading-anchor-permalink" href="#文件名、路径名截断-1" title="Permalink"></a></h3><h2 id="creat-函数-1"><a class="docs-heading-anchor" href="#creat-函数-1"><code>creat</code> 函数</a><a class="docs-heading-anchor-permalink" href="#creat-函数-1" title="Permalink"></a></h2><pre><code class="language-c">#include &lt;fcntl.h&gt;
int creat(const char *path, mode_t mode);</code></pre><p>返回结果是一个可写的文件描述符。</p><h2 id="close-函数-1"><a class="docs-heading-anchor" href="#close-函数-1"><code>close</code> 函数</a><a class="docs-heading-anchor-permalink" href="#close-函数-1" title="Permalink"></a></h2><pre><code class="language-c">#include &lt;unistd.h&gt;
int close(int fd);</code></pre><p>当一个进程结束时，kernel会自动关闭进程相关的所有文件。</p><h2 id="lseek-函数-1"><a class="docs-heading-anchor" href="#lseek-函数-1"><code>lseek</code> 函数</a><a class="docs-heading-anchor-permalink" href="#lseek-函数-1" title="Permalink"></a></h2><pre><code class="language-c">#include &lt;unistd.h&gt;
off_t lseek(int fd, off_t offset, int whence);</code></pre><p>打开文件时，默认指向文件的开头，除非设置了<code>O_APPEND</code>。 whence可以设置为</p><ol><li>SEEK_SET</li><li>SEEK_CUR</li><li>SEEK_END</li></ol><p>某些文件描述符无法seek，如<code>FIFO</code>，socket等。 lseek只在内核中记录文件的offset</p><h2 id="read-函数-1"><a class="docs-heading-anchor" href="#read-函数-1"><code>read</code> 函数</a><a class="docs-heading-anchor-permalink" href="#read-函数-1" title="Permalink"></a></h2><pre><code class="language-c">#include &lt;unistd.h&gt;
ssize_t read(int fd, void *buf, size_t nbytes);</code></pre><p>从文件描述符读取指定长短的内容，返回读到的长度。</p><h2 id="write-函数-1"><a class="docs-heading-anchor" href="#write-函数-1"><code>write</code> 函数</a><a class="docs-heading-anchor-permalink" href="#write-函数-1" title="Permalink"></a></h2><pre><code class="language-c">#include &lt;unistd.h&gt;
ssize_t write(int fd, const void *buf, size_t nbytes);</code></pre><p>返回写入的长度，若发生错误，返回<code>-1</code></p><h2 id="IO-效率-1"><a class="docs-heading-anchor" href="#IO-效率-1">IO 效率</a><a class="docs-heading-anchor-permalink" href="#IO-效率-1" title="Permalink"></a></h2><p><code>read</code>和<code>write</code>函数均要指定缓存区大小。 过小的缓存会增加系统调用的次数，过大的缓存会造成内存浪费，所以这里存在一个调优的问题。 但实际的现代系统内核，往往有读写预缓存的优化。</p><h2 id="文件共享-1"><a class="docs-heading-anchor" href="#文件共享-1">文件共享</a><a class="docs-heading-anchor-permalink" href="#文件共享-1" title="Permalink"></a></h2><h2 id="原子操作-1"><a class="docs-heading-anchor" href="#原子操作-1">原子操作</a><a class="docs-heading-anchor-permalink" href="#原子操作-1" title="Permalink"></a></h2><p>文件共享时，有数据竟写的可能，所以需要原子操作。</p><h3 id="pread和pwrite函数-1"><a class="docs-heading-anchor" href="#pread和pwrite函数-1"><code>pread</code>和<code>pwrite</code>函数</a><a class="docs-heading-anchor-permalink" href="#pread和pwrite函数-1" title="Permalink"></a></h3><p>pread函数相当于lseek和write无间断连续运行。</p><h2 id="dup-dup2函数-1"><a class="docs-heading-anchor" href="#dup-dup2函数-1">dup dup2函数</a><a class="docs-heading-anchor-permalink" href="#dup-dup2函数-1" title="Permalink"></a></h2><p>没看</p><h2 id="sysnc，-fsync-和-fdatasync-函数-1"><a class="docs-heading-anchor" href="#sysnc，-fsync-和-fdatasync-函数-1"><code>sysnc</code>， <code>fsync</code> 和 <code>fdatasync</code> 函数</a><a class="docs-heading-anchor-permalink" href="#sysnc，-fsync-和-fdatasync-函数-1" title="Permalink"></a></h2><p>UNIX类系统为了读写优化，一般都启用了延迟写入特性。 如果我们需要同步磁盘与内存缓存，会用到以下几个函数。</p><pre><code class="language-c">#include &lt;unistd.h&gt;
int fsync(int fd);
int fdatasync(int fd);
void sync(void);</code></pre><p><code>fdatasync</code>和<code>fsync</code>类似，差别在于是否同步文件属性。</p><h2 id="fcntl函数-1"><a class="docs-heading-anchor" href="#fcntl函数-1"><code>fcntl</code>函数</a><a class="docs-heading-anchor-permalink" href="#fcntl函数-1" title="Permalink"></a></h2><h2 id="ioctl函数-1"><a class="docs-heading-anchor" href="#ioctl函数-1"><code>ioctl</code>函数</a><a class="docs-heading-anchor-permalink" href="#ioctl函数-1" title="Permalink"></a></h2><h2 id="/dev/fd-1"><a class="docs-heading-anchor" href="#/dev/fd-1"><code>/dev/fd</code></a><a class="docs-heading-anchor-permalink" href="#/dev/fd-1" title="Permalink"></a></h2><h1 id="文件和目录-2"><a class="docs-heading-anchor" href="#文件和目录-2">文件和目录</a><a class="docs-heading-anchor-permalink" href="#文件和目录-2" title="Permalink"></a></h1><h2 id="简介-4"><a class="docs-heading-anchor" href="#简介-4">简介</a><a class="docs-heading-anchor-permalink" href="#简介-4" title="Permalink"></a></h2><p>这一章介绍一些文件系统的特性和文件属性。这一章从介绍<code>stat</code>函数开始。</p><h2 id="stat-函数等-1"><a class="docs-heading-anchor" href="#stat-函数等-1"><code>stat</code> 函数等</a><a class="docs-heading-anchor-permalink" href="#stat-函数等-1" title="Permalink"></a></h2><pre><code class="language-c">#include &lt;sys/stat.h&gt;
int stat(const char *restrict pathname, struct stat *restrict buf);
int fstat
int lstat
int fstatat</code></pre><pre><code class="language-c">struct stat {
    mode_t          st_mode;    /* file type &amp; mode (permissions) */
    ino_t           st_ino;     /* i-node number (serial number) */
    dev_t           st_dev;     /* device number (file system) */
    dev_t           st_rdev;    /* device number for special files */
    nlink_t         st_nlink;   /* number of links */
    uid_t           st_uid;     /* user ID of owner */
    gid_t           st_gid;     /* group ID of owner */
    off_t           st_size;    /* size in bytes, for regular files */
    struct timespec st_atim;    /* time of last access */
    struct timespec st_mtim;    /* time of last modification */
    struct timespec st_ctim;    /* time of last file status change */
    blksize_t       st_blksize; /* best I/O block size */
    blkcnt_t        st_blocks;  /* number of disk blocks allocated */
};</code></pre><h2 id="文件类型-1"><a class="docs-heading-anchor" href="#文件类型-1">文件类型</a><a class="docs-heading-anchor-permalink" href="#文件类型-1" title="Permalink"></a></h2><ol><li>普通文件</li><li>目录</li><li>块设备文件</li><li>字符设备文件</li><li>管道FIFO</li><li>套接字Socket</li><li>符号链接</li></ol><h2 id="Set-User-ID-and-Set-Group-ID-1"><a class="docs-heading-anchor" href="#Set-User-ID-and-Set-Group-ID-1">Set-User-ID and Set-Group-ID</a><a class="docs-heading-anchor-permalink" href="#Set-User-ID-and-Set-Group-ID-1" title="Permalink"></a></h2><p>每一个进程都至少关联有六个ID。每一个文件都从属于某各人和组。 UNIX系统允许每个用户修改自己的密码。当普通用户执行passwd，程序可以获得/etc/passwd文件的读写权限，而这个文件的主人，显然是root。</p><h2 id="文件访问权限-1"><a class="docs-heading-anchor" href="#文件访问权限-1">文件访问权限</a><a class="docs-heading-anchor-permalink" href="#文件访问权限-1" title="Permalink"></a></h2><h2 id="创建新文件时的所有权-1"><a class="docs-heading-anchor" href="#创建新文件时的所有权-1">创建新文件时的所有权</a><a class="docs-heading-anchor-permalink" href="#创建新文件时的所有权-1" title="Permalink"></a></h2><p>文件创建时的所有者为进程的有效uid。文件的组id可以从进程，也可以从所属目录。</p><h2 id="access-和-faccessat-函数-1"><a class="docs-heading-anchor" href="#access-和-faccessat-函数-1"><code>access</code> 和 <code>faccessat</code> 函数</a><a class="docs-heading-anchor-permalink" href="#access-和-faccessat-函数-1" title="Permalink"></a></h2><pre><code class="language-c">#include &lt;unistd.h&gt;
int access(const char *pathname, int mode);
int faccessat(int fd, const char *pathname, int mode, int flag);</code></pre><h2 id="umask-1"><a class="docs-heading-anchor" href="#umask-1"><code>umask</code></a><a class="docs-heading-anchor-permalink" href="#umask-1" title="Permalink"></a></h2><h2 id="chmod,-fchmod,-fchmodat-函数-1"><a class="docs-heading-anchor" href="#chmod,-fchmod,-fchmodat-函数-1"><code>chmod</code>, <code>fchmod</code>, <code>fchmodat</code> 函数</a><a class="docs-heading-anchor-permalink" href="#chmod,-fchmod,-fchmodat-函数-1" title="Permalink"></a></h2><h2 id="chown,-fchown,-lchown-1"><a class="docs-heading-anchor" href="#chown,-fchown,-lchown-1"><code>chown</code>, <code>fchown</code>, <code>lchown</code></a><a class="docs-heading-anchor-permalink" href="#chown,-fchown,-lchown-1" title="Permalink"></a></h2><h2 id="文件大小-1"><a class="docs-heading-anchor" href="#文件大小-1">文件大小</a><a class="docs-heading-anchor-permalink" href="#文件大小-1" title="Permalink"></a></h2><p>文件可以有“洞”</p><h2 id="文件截断-1"><a class="docs-heading-anchor" href="#文件截断-1">文件截断</a><a class="docs-heading-anchor-permalink" href="#文件截断-1" title="Permalink"></a></h2><pre><code class="language-c">#include &lt;unistd.h&gt;
int truncate(const char *pathname, off_t length);
int ftruncate(int fd, off_t length);</code></pre><h2 id="文件系统-2"><a class="docs-heading-anchor" href="#文件系统-2">文件系统</a><a class="docs-heading-anchor-permalink" href="#文件系统-2" title="Permalink"></a></h2></article></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Tuesday 28 January 2020 08:42">Tuesday 28 January 2020</span>. Using Julia version 1.3.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
