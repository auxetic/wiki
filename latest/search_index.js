var documenterSearchIndex = {"docs": [

{
    "location": "index.html#",
    "page": "Home",
    "title": "Home",
    "category": "page",
    "text": ""
},

{
    "location": "index.html#wiki-1",
    "page": "Home",
    "title": "wiki",
    "category": "section",
    "text": "note: Note\nThis is a wiki(or blog) generated by Documenter.jlDocumenter, a package for building documentation from docstrings and markdown files.warn: Warn\nPlease read through the Documentation section of the main Julia manual if this is your first time using Julia\'s documentation system. Once you\'ve read through how to write documentation for your code then come back here."
},

{
    "location": "index.html#Contents-1",
    "page": "Home",
    "title": "Contents",
    "category": "section",
    "text": ""
},

{
    "location": "index.html#Title-1",
    "page": "Home",
    "title": "Title",
    "category": "section",
    "text": "Write all your documentation in Markdown.\nMinimal configuration.\nSupports Julia 0.6 and 0.7-dev.c code#include<stdio.h>\n\nint main(int argc, char *argv[])\n{\n    char word[10];\n    puts(\"enter sth\");\n    while (fgets(word,10,stdin) != NULL && word[0] != \'\\n\')\n        fputs(word,stdout);\n    puts(\"done\");\n    return 0;\n}"
},

{
    "location": "Fortran/Qsort.html#",
    "page": "Quick Sort",
    "title": "Quick Sort",
    "category": "page",
    "text": ""
},

{
    "location": "Fortran/Qsort.html#Quick-Sort-1",
    "page": "Quick Sort",
    "title": "Quick Sort",
    "category": "section",
    "text": "module msort\n    implicit none\n\ncontains\n\n    function selectpivot(dataset,istart,iend) result(pivot)\n        implicit none\n\n        real(8), dimension(:) :: dataset\n        integer, value :: istart, iend\n        integer :: imid\n        real(8) :: pivot\n        real(8) :: tmp\n\n        imid = (istart+iend) / 2\n\n        if ( dataset(istart) > dataset(imid) ) then\n            tmp = dataset(istart)\n            dataset(istart) = dataset(imid)\n            dataset(imid) = tmp\n        end if\n\n        if ( dataset(iend) < dataset(imid) ) then\n            if ( dataset(iend) > dataset(istart) ) then\n                tmp = dataset(iend)\n                dataset(iend) = dataset(imid)\n                dataset(imid) = tmp\n            else\n                tmp = dataset(iend)\n                dataset(iend) = dataset(imid)\n                dataset(imid) = dataset(istart)\n                dataset(istart) = tmp\n            end if\n        end if\n\n        !^ istart <= imid <= iend\n\n        tmp = dataset(imid)\n        dataset(imid) = dataset(istart)\n        dataset(istart) = tmp\n\n        !^ swap istart and imid\n\n        pivot = tmp\n    end function\n\n    function partition(dataset,istart,iend) result(ipivot)\n        implicit none\n\n        real(8), dimension(:) :: dataset\n        integer, value :: istart, iend\n        integer :: ipivot\n        real(8) :: pivot\n        integer :: i, j\n        real(8) :: tmp\n\n        i = istart\n        j = iend\n\n        pivot = selectpivot(dataset,istart,iend)\n\n        do\n            i = i + 1\n            j = j - 1\n            do while ( dataset(i) < pivot )\n                i = i + 1\n            end do\n            do while ( dataset(j) > pivot )\n                j = j - 1\n            end do\n            if ( i>=j ) exit\n            tmp = dataset(j)\n            dataset(j) = dataset(i)\n            dataset(i) = tmp\n        end do\n        dataset(istart) = dataset(j)\n        dataset(j) = pivot\n\n        ipivot = j\n    end function\n\n    recursive subroutine sort_kernel(dataset,istart,iend)\n        implicit none\n\n        real(8), dimension(:) :: dataset\n        integer, value :: istart, iend\n        integer :: ipivot\n\n        do while ( istart < iend )\n            ipivot = partition(dataset,istart,iend)\n            if ( ipivot-istart < iend-ipivot ) then\n                if ( istart < ipivot-1 ) then\n                    call sort_kernel(dataset,istart,ipivot-1)\n                end if\n                istart = ipivot + 1\n            else\n                if ( iend > ipivot+1 ) then\n                    call sort_kernel(dataset,ipivot+1,iend)\n                end if\n                iend = ipivot - 1\n            end if\n        end do\n    end subroutine\n\n    subroutine sort(dataset)\n        implicit none\n\n        real(8), dimension(:) :: dataset\n        integer :: n\n\n        n = size(dataset)\n\n        call sort_kernel(dataset,1,n)\n    end subroutine\n\n    function issorted(dataset) result(re)\n        implicit none\n\n        real(8), dimension(:) :: dataset\n        logical :: re\n        integer :: i\n\n        re = .true.\n\n        do i=2, size(dataset)\n            if ( dataset(i) < dataset(i-1) ) then\n                re = .false.\n                exit\n            end if\n        end do\n    end function\n\nend module"
},

{
    "location": "LeetCode/twostring.html#",
    "page": "String",
    "title": "String",
    "category": "page",
    "text": ""
},

{
    "location": "LeetCode/twostring.html#String-1",
    "page": "String",
    "title": "String",
    "category": "section",
    "text": ""
},

{
    "location": "LeetCode/twostring.html#add-and-product-of-two-numeric-string-1",
    "page": "String",
    "title": "add and product of two numeric string",
    "category": "section",
    "text": "function s_add(s1::String, s2::String)\n    !( all(isnumeric,s1) && all(isnumeric,s2) ) && error(\"xx\")\n\n    l1 = length(s1)\n    l2 = length(s2)\n    l  = max(l1,l2) + 1\n    v  = zeros(Int8,l)\n    \n    for i in 1:l-1\n        x1 = i<=l1 ? s1[l1+1-i] - \'0\' : 0\n        x2 = i<=l2 ? s2[l2+1-i] - \'0\' : 0\n        x = x1 + x2\n        if x >= 10\n            v[l+1-i] += x - 10\n            v[l-i]   += 1\n        else\n            v[l+1-i] += x\n        end\n    end\n\n    v[1] != 0 ? reduce(*,string.(v)) : reduce(*,string.(v[2:end]))\nend\n\nusing Test\n@testset \"s_add\" begin\n    @test s_add(\"1\",\"2\") == \"3\"\n    @test s_add(\"1\",\"9\") == \"10\"\n    @test s_add(\"11\",\"99\") == \"110\"\n    @test_throws ErrorException s_add(\"a\",\"2\")\nendfunction s_mul(s1::String, s2::String)\n    !( all(isnumeric,s1) && all(isnumeric,s2) ) && error(\"xx\")\n\n    l1 = length(s1)\n    l2 = length(s2)\n    l  = l1 + l2\n    v  = zeros(Int8,l)\n    \n    for i1 in 1:l1\n        x1 = s1[l1+1-i1] - \'0\'\n        for i2 in 1:l2\n            x2 = s2[l2+1-i2] - \'0\'\n            v[l+2-i1-i2] += x1 * x2\n        end\n    end\n\n    for i in l:-1:1\n        x = v[i]\n        if x>10\n            v[i]    = x%10\n            v[i-1] += floor(Int8,x/10)\n        end\n    end\n\n    v[1] != 0 ? reduce(*,string.(v)) : reduce(*,string.(v[2:end]))\nend\n\nusing Test\n@testset \"s_mul\" begin\n    @test s_mul(\"2\",\"3\") == \"6\"\n    @test s_mul(\"3\",\"7\") == \"21\"\n    @test_throws ErrorException s_mul(\"a\",\"2\")\nend"
},

{
    "location": "LeetCode/palindrome.html#",
    "page": "Palindrome",
    "title": "Palindrome",
    "category": "page",
    "text": ""
},

{
    "location": "LeetCode/palindrome.html#Palindrome-1",
    "page": "Palindrome",
    "title": "Palindrome",
    "category": "section",
    "text": "determine if a integer or string is palindrome."
},

{
    "location": "LeetCode/palindrome.html#Integer-1",
    "page": "Palindrome",
    "title": "Integer",
    "category": "section",
    "text": "function ispa(x::T) where T <: Signed\n    @assert(x>0)\n    y = x\n    z = zero(x)\n    while y != 0\n        z = 10 * z + y%10\n        y = floor(T,y/10)\n    end\n    z == x\nend\n\nusing Test\n@testset \"integer\" begin\n    @test ispa(1)   == true\n    @test ispa(11)  == true\n    @test ispa(12)  == false\n    @test ispa(121) == true\n    @test ispa(122) == false\n    @test_throws MethodError ispa(1.0)\n    @test_throws AssertionError ispa(-11)\nend"
},

{
    "location": "LeetCode/palindrome.html#String-1",
    "page": "Palindrome",
    "title": "String",
    "category": "section",
    "text": "function ispa(x::String)\n    i = 1\n    j = length(x)\n    while i <= j\n        !( isnumeric(x[i]) || isalpha(x[i]) ) && (i += 1)\n        !( isnumeric(x[j]) || isalpha(x[j]) ) && (j -= 1)\n        x[i] != x[j] && return false\n        i += 1; j -= 1\n    end\n    return true\nend\n\nusing Test\n@testset \"string\" begin\n    @test ispa(\"121\")   == true\n    @test ispa(\"aba\")   == true\n    @test ispa(\"abc\")   == false\n    @test ispa(\"a,b.a\") == true\nend"
},

{
    "location": "LeetCode/array.html#",
    "page": "Array",
    "title": "Array",
    "category": "page",
    "text": ""
},

{
    "location": "LeetCode/array.html#Array-1",
    "page": "Array",
    "title": "Array",
    "category": "section",
    "text": ""
},

{
    "location": "LeetCode/array.html#Rm-duplicates-A-1",
    "page": "Array",
    "title": "Rm duplicates A",
    "category": "section",
    "text": "Remove duplicates from Sorted arrayusing Testx = sort(rand(1:4,10))\nfunction rmdup!(x)\n    idx = 1\n    for i in 2:length(x)\n        if x[idx] != x[i]\n            idx += 1\n            x[idx] = x[i]\n        end\n    end\n    idx\nend"
},

{
    "location": "LeetCode/array.html#Rm-duplicates-B-1",
    "page": "Array",
    "title": "Rm duplicates B",
    "category": "section",
    "text": "Fellow up probrem, add allow elements duplicate once.function rmdup!(x)\n    idx = 2\n    for i in 3:length(x)\n        if x[idx-1] != x[i]\n            idx += 1\n            x[idx] = x[i]\n        end\n    end\n    idx\nend"
},

{
    "location": "LeetCode/array.html#Search-array-1",
    "page": "Array",
    "title": "Search array",
    "category": "section",
    "text": "x is a sorted array and circle shift 3 index, find the target value and give its idx.x = [1:10;]\nx = circshift(x,3)\n\nfunction findta(x,ta)\n    n1 = 1\n    n3 = length(x)\n    while n3 >= n1\n        n2 = (n1+n3) >> 1\n        x[n2] == ta && return n2\n\n        if x[n2] >= x[n1]\n            if x[n2] >= ta >= x[n1]\n                n3 = n2\n            else\n                n1 = n2 + 1\n            end\n        else\n            if ta>=x[n1] || ta<=x[n2]\n                n3 = n2\n            else\n                n1 = n2 + 1\n            end\n        end\n    end\n    -1\nend"
},

{
    "location": "LeetCode/hash.html#",
    "page": "Hash",
    "title": "Hash",
    "category": "page",
    "text": ""
},

{
    "location": "LeetCode/hash.html#Hash-1",
    "page": "Hash",
    "title": "Hash",
    "category": "section",
    "text": ""
},

{
    "location": "LeetCode/hash.html#Group-anagrams-1",
    "page": "Hash",
    "title": "Group anagrams",
    "category": "section",
    "text": "Given an array of strings, like [\"tan\", \"nat\", \"ant\", \"abc\", \"cc\", \"bca\" ], return:[\n    [\"tan\", \"nat\", \"ant\"],\n    [\"abc\", \"bca\"],\n    [\"cc\"]\n]mutable struct Stringhash\n    s::String\n    h::Set\n    hit::Bool\nend\n\nfunction dictgroup(sarray::Vector{String})\n\n    result = Vector{String}[]\n\n    sst = Stringhash[]\n    for si in sarray\n        push!(sst,Stringhash(si,Set([si...]),false))\n    end\n\n    for i in 1:length(sst)\n        sst[i].hit == true && continue\n\n        rtemp = String[]\n        push!(rtemp,sst[i].s)\n\n        for j in i+1:length(sst)\n            if sst[i].h == sst[j].h\n                sst[j].hit = true\n                push!(rtemp,sst[j].s)\n            end\n        end\n\n        push!(result,rtemp)\n    end\n\n    return result\n\nend"
},

{
    "location": "LeetCode/heap.html#",
    "page": "Heap",
    "title": "Heap",
    "category": "page",
    "text": ""
},

{
    "location": "LeetCode/heap.html#Heap-1",
    "page": "Heap",
    "title": "Heap",
    "category": "section",
    "text": ""
},

{
    "location": "LeetCode/heap.html#find-n-largest-numbers-of-given-array.-1",
    "page": "Heap",
    "title": "find n largest numbers of given array.",
    "category": "section",
    "text": "Use julia\'s DataStructures library.using DataStructures\n\nx = rand(1000);\nnlargest(10,x)Use numpy\'s partial sortimport numpy as np\n\nx = np.random.rand(1000);\nnp.argpartition(x, -10)[-10:]"
},

{
    "location": "YearBook/index.html#",
    "page": "历史年鉴",
    "title": "历史年鉴",
    "category": "page",
    "text": ""
},

{
    "location": "YearBook/index.html#历史年鉴-1",
    "page": "历史年鉴",
    "title": "历史年鉴",
    "category": "section",
    "text": ""
},

{
    "location": "YearBook/index.html#?-新（汉）-1",
    "page": "历史年鉴",
    "title": "? - 新（汉）",
    "category": "section",
    "text": "note: Note\n以新朝分界，界线分明209 BCE  陈胜吴广起义"
},

{
    "location": "YearBook/index.html#新中国-1",
    "page": "历史年鉴",
    "title": "新中国",
    "category": "section",
    "text": ""
},

{
    "location": "YearBook/index.html#-1",
    "page": "历史年鉴",
    "title": "1971",
    "category": "section",
    "text": "7.9-11  美国总统国家安全事物助理亨利·基辛格秘密访华"
},

{
    "location": "YearBook/index.html#-2",
    "page": "历史年鉴",
    "title": "1972",
    "category": "section",
    "text": "2.21-28  美国总统理查德·尼克松访华\n2.28     中美签署《上海公报》\n9.25     日本首相田中角荣访华\n9.29     中日建交"
},

{
    "location": "YearBook/index.html#-3",
    "page": "历史年鉴",
    "title": "1979",
    "category": "section",
    "text": "1.1 中美建交，共同发布《中美建交公报》"
},

{
    "location": "YearBook/index.html#-4",
    "page": "历史年鉴",
    "title": "1982",
    "category": "section",
    "text": "8.17 中美签署《八一七公报》，全称《中美就解决美国向台出售武器问题的公告》"
},

]}
